! Rui Wen 2020.01.20
MODULE NEWTV_SAVE
  IMPLICIT NONE
  SAVE
  INTEGER,PARAMETER :: NP=40
  INTEGER :: NN
  REAL(16) :: FVEC(NP)
END MODULE NEWTV_SAVE

SUBROUTINE NEWT(X, N, CHECK, FUNCTIONN)

  USE ERRORSHOW
  USE NEWTV_SAVE
  IMPLICIT NONE

  INTEGER N, MAXITS
  LOGICAL CHECK
  REAL(16) X(N),TOLF, TOLMIN, TOLX, STPMX
  PARAMETER (MAXITS=200, TOLF=1.Q-6, TOLMIN=1.Q-8, TOLX=1.Q-9, STPMX=100.Q+0)
  INTEGER I, ITS, J, INDX(NP)
  REAL(16) D, DEN, F, FOLD, STPMAX, SUMSQ, TEMP, TEST, FJAC(NP,NP), G(NP), P(NP), XOLD(NP)
  EXTERNAL FFMIN, FUNCTIONN

  NN=N
  CALL FFMIN(X, F, FUNCTIONN)
  TEST=MAXVAL(ABS(FVEC(1:N)))
  !TEST FOR INITIAL GUESS BEING A ROOT.

  IF(TEST<0.01Q+0*TOLF) THEN
    CHECK=.FALSE.
    RETURN
  END IF

  SUMSQ=SUM(X(1:N)**2)
  STPMAX=STPMX*MAX(SQRT(SUMSQ),REAL(N,KIND=16))
  !CALCULATE STPMAX FOR LINE SEARCHES

  DO ITS=1, MAXITS
  !START OF ITERATION LOOP
    CALL FDJAC(N, X, FVEC, NP, FJAC, FUNCTIONN)
    !IF ANALYTIC JACOBIAN IS AVAILABLE, YOU CAN REPLACE THE ROUTINE FDJAC WITH YOUR OWN ROUTINE.
    DO I=1, N
      G(I)=SUM(FJAC(1:N,I)*FVEC(1:N))
      !COMPUTE GRAD F FOR THE LINE SEARCH
    END DO

    XOLD(1:N)=X(1:N)
    !STORE X
    FOLD=F                           
    !STORE F
    P(1:N)=-FVEC(1:N)
    !RIGHT HAND SIDE FOR LINEAR EQUATIONS

    CALL LUDCMP(FJAC, N, NP, INDX, D)
    !SOLVE LINEAR EQUATIONS BY LU DECOMPOSITION
    CALL LUBKSB(FJAC, N, NP, INDX, P)
    CALL LNSRCH(N, XOLD, FOLD, G, P, X, F, STPMAX, CHECK, FFMIN, FUNCTIONN)
    !LNSRCH RETURNS NEW X AND F. IT ALSO CALCULATES FVEC AT THE NEW X WHEN IT CALLS FMIN

    TEST=MAXVAL(ABS(FVEC(1:N)))
    !TEST FOR CONVERGENCE ON FUNCTION VALUES

    IF(TEST < TOLF) THEN
      CHECK=.FALSE.
      RETURN
    END IF

    IF(CHECK) THEN
    !CHECK FOR GRADIENT OF F ZERO, I.E., SPURIOUS CONVERGENCE
      DEN=MAX(F,0.5Q+0*N)
      TEST=MAXVAL(ABS(G(1:N))*MAX(ABS(X(1:N)),1.Q+0)/DEN)
      IF(TEST < TOLMIN)THEN
        CHECK=.TRUE.
      ELSE
        CHECK=.FALSE.
      ENDIF
      RETURN
    ENDIF

    TEST=MAXVAL((ABS(X(1:N)-XOLD(1:N)))/MAX(ABS(X(1:N)),1.Q+0))
    !TEST FOR CONVERGENCE ON DELT-X
    IF(TEST < TOLX)RETURN
  END DO
  CALL NRERROR('MAXITS EXCEEDED IN NEWT')
END SUBROUTINE NEWT

SUBROUTINE FFMIN(X, F, FUNCTIONN)

  USE NEWTV_SAVE
  IMPLICIT NONE

  REAL(16) F
  REAL(16) X(40)
  REAL(16) :: SUMSQ
  EXTERNAL FUNCTIONN

  CALL FUNCTIONN(NN, X, FVEC)
  SUMSQ=SUM(FVEC(1:NN)**2)
  F=0.5Q+0*SUMSQ

END SUBROUTINE FFMIN

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

SUBROUTINE FDJAC(N, X, FVEC, NP, DF, FUNCTIONN)

  IMPLICIT NONE

  INTEGER N, NP
  REAL(16) DF(NP,NP), FVEC(N), X(N), EPS
  PARAMETER (EPS=1.Q-6)
  INTEGER I, J
  REAL(16) H, TEMP, F(NP)
  EXTERNAL FUNCTIONN

  DO J=1, N
    TEMP=X(J)
    H=EPS*ABS(TEMP)
    IF(H==0.Q+0)H=EPS
    X(J)=TEMP+H
    !TRICK TO REDUCE FINITE PRECISION ERROR
    H=X(J)-TEMP
    CALL FUNCTIONN(N, X, F)
    X(J)=TEMP
    DF(1:N,J)=(F(1:N)-FVEC(1:N))/H
    !FORWARD DIFFERENCE FORMULA
  ENDDO

END SUBROUTINE FDJAC


SUBROUTINE LNSRCH(N, XOLD, FOLD, G, P, X, F, STPMAX, CHECK, FUNC, FUNCTIONN)

  USE ERRORSHOW
  IMPLICIT NONE

  INTEGER N
  LOGICAL CHECK
  REAL(16) F, FOLD, STPMAX, G(N), P(N), X(N), XOLD(N), ALF, TOLX
  PARAMETER (ALF=1.Q-6,TOLX=1.Q-9)
  EXTERNAL FUNC, FUNCTIONN
  INTEGER I
  REAL(16) A, ALAM, ALAM2, ALAMIN, B, DISC, F2, FOLD2, RHS1, RHS2, SLOPE
  REAL(16) SUMSQ, TEMP, TEST, TMPLAM

  LOGICAL LOOPCOL

  CHECK=.FALSE.

  SUMSQ=SQRT(SUM(P(1:N)*P(1:N)))

  IF(SUMSQ>STPMAX) THEN
    P(1:N)=P(1:N)*STPMAX/SUMSQ
  ENDIF

  SLOPE=DOT_PRODUCT(G(1:N),P(1:N))
  TEST=MAXVAL(ABS(P(1:N))/MAX(ABS(XOLD(1:N)),1.Q+0))
  ALAMIN=TOLX/TEST
  ALAM=1.Q+0

  LOOPCOL=.TRUE.
  DO WHILE (LOOPCOL)
    X(1:N)=XOLD(1:N)+ALAM*P(1:N)

    CALL FUNC(X, F, FUNCTIONN)
    IF(ALAM < ALAMIN) THEN
      X(1:N)=XOLD(1:N)
      CHECK=.TRUE.
      LOOPCOL=.FALSE.
    ELSEIF(F <= FOLD+ALF*ALAM*SLOPE) THEN
      LOOPCOL=.FALSE.
    ELSE
      IF(ALAM == 1.Q+0) THEN
        TMPLAM=-SLOPE/(2.Q+0*(F-FOLD-SLOPE))
      ELSE
        RHS1=F-FOLD-ALAM*SLOPE
        RHS2=F2-FOLD2-ALAM2*SLOPE
        A=(RHS1/ALAM**2-RHS2/ALAM2**2)/(ALAM-ALAM2)
        B=(-ALAM2*RHS1/ALAM**2+ALAM*RHS2/ALAM2**2)/(ALAM-ALAM2)
        IF(A == 0.Q+0) THEN
          TMPLAM=-SLOPE/(2.Q+0*B)
        ELSE
          DISC=B*B-3.Q+0*A*SLOPE
          IF(DISC < 0.Q+0) CALL NRERROR('ROUNDOFF PROBLEM IN LNSRCH')
          TMPLAM=(-B+SQRT(DISC))/(3.Q+0*A)
        ENDIF
      ENDIF
      IF(TMPLAM > 0.5Q+0*ALAM) TMPLAM=0.5Q+0*ALAM
      ALAM2=ALAM
      F2=F
      FOLD2=FOLD
      ALAM=MAX(TMPLAM,0.1Q+0*ALAM)
    ENDIF
  ENDDO

END SUBROUTINE LNSRCH

SUBROUTINE LUBKSB(A, N, NP, INDX, B)
!FORWARD SUBSTITUTION AND BACKSUBSTITUTION

  IMPLICIT NONE

  INTEGER N, NP, INDX(N)
  REAL(16) A(NP,NP), B(N)
  INTEGER I, II, J, LL
  REAL(16) SUMT

  II=0
  DO I=1, N
    LL=INDX(I)
    SUMT=B(LL)
    B(LL)=B(I)
    IF (II /= 0) THEN
      DO J=II, I-1
        SUMT=SUMT-A(I,J)*B(J)
      END DO
    ELSEIF (SUMT /= 0.Q+0) THEN
      II=I
    ENDIF
    B(I)=SUMT
  END DO

  DO I=N, 1, -1
    SUMT=B(I)
    DO J=I+1, N
      SUMT=SUMT-A(I,J)*B(J)
    ENDDO
    B(I)=SUMT/A(I,I)
  ENDDO
END SUBROUTINE LUBKSB


SUBROUTINE LUDCMP(A, N, NP, INDX, D)

  USE ERRORSHOW
  IMPLICIT NONE

  INTEGER N, NP, INDX(N), NMAX
  REAL(16) D, A(NP,NP), TINYR
  PARAMETER (NMAX=10,TINYR=1.0Q-21)
  INTEGER I, IMAX, J, K
  REAL(16) AAMAX, DUM, SUMT, VV(NMAX)

  D=1.0
  DO I=1, N
    AAMAX=MAXVAL(ABS(A(I,1:N)))
    IF (AAMAX == 0.Q+0) CALL NRERROR('SINGULAR MATRIX IN LUDCMP')
    VV(I)=1.0/AAMAX
  END DO
  DO J=1, N
    DO I=1, J-1
      SUMT=A(I,J)-SUM(A(I,1:(I-1))*A(1:(I-1),J))
      A(I,J)=SUMT
    END DO

    AAMAX=0.0
    DO I=J, N
      SUMT=A(I,J)-SUM(A(I,1:(J-1))*A(1:(J-1),J))
      A(I,J)=SUMT
      DUM=VV(I)*ABS(SUMT)
      IF (DUM >= AAMAX) THEN
        IMAX=I
        AAMAX=DUM
      ENDIF
    END DO
    IF (J /= IMAX) THEN
      DO K=1, N
        DUM=A(IMAX,K)
        A(IMAX,K)=A(J,K)
        A(J,K)=DUM
      ENDDO
      D=-D
      VV(IMAX)=VV(J)
    ENDIF
    INDX(J)=IMAX
    IF(A(J,J) == 0.Q+0) A(J,J)=TINYR
    IF(J /= N)THEN
      DUM=1.Q+0/A(J,J)
      A(J+1:N,J)=A(J+1:N,J)*DUM
    ENDIF
  ENDDO
END SUBROUTINE LUDCMP
